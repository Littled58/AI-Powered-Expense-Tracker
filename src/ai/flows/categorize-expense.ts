
// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview AI-powered expense categorization flow.
 *
 * This file defines a Genkit flow that takes an expense description
 * and predicts its category.
 *
 * - categorizeExpense - The main function to categorize an expense.
 * - CategorizeExpenseInput - The input type for the categorizeExpense function.
 * - CategorizeExpenseOutput - The output type for the categorizeExpense function.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';

const CategorizeExpenseInputSchema = z.object({
  description: z.string().describe('The description of the expense provided by the user (e.g., "Weekly groceries", "Coffee with friends", "Train ticket to downtown").'),
});
export type CategorizeExpenseInput = z.infer<typeof CategorizeExpenseInputSchema>;

// Define the list of valid categories for better validation and prompting
const validCategories = [
    "Food", "Transportation", "Entertainment", "Utilities", "Housing",
    "Healthcare", "Personal Care", "Shopping", "Travel", "Debt Payment",
    "Education", "Gifts & Donations", "Other"
] as const; // Use 'as const' for literal types

const CategorizeExpenseOutputSchema = z.object({
  category: z.enum(validCategories).describe(`The predicted category for the expense. Must be one of: ${validCategories.join(', ')}.`),
});
export type CategorizeExpenseOutput = z.infer<typeof CategorizeExpenseOutputSchema>;

export async function categorizeExpense(input: CategorizeExpenseInput): Promise<CategorizeExpenseOutput> {
  return categorizeExpenseFlow(input);
}

const categorizeExpensePrompt = ai.definePrompt({
  name: 'categorizeExpensePrompt',
  input: {
    schema: CategorizeExpenseInputSchema,
  },
  output: {
    schema: CategorizeExpenseOutputSchema,
  },
  prompt: `Analyze the following expense description and categorize it into exactly one of the predefined categories.

Expense Description: {{{description}}}

Categories:
${validCategories.map(cat => `- ${cat}`).join('\n')}
(Food includes Groceries, restaurants, coffee shops. Transportation includes Gas, public transport, ride shares, parking. Entertainment includes Movies, concerts, streaming services, hobbies. Utilities includes Electricity, water, internet, phone bill. Housing includes Rent, mortgage, property taxes, home insurance. Healthcare includes Doctor visits, prescriptions, health insurance. Personal Care includes Haircuts, toiletries, gym membership. Shopping includes Clothing, electronics, household items. Travel includes Flights, hotels, vacation expenses. Debt Payment includes Credit card payments, loan payments. Education includes Tuition, books, courses. Gifts & Donations include Charitable donations, gifts for others. Use Other for anything that doesn't fit.)

Based only on the description "{{{description}}}", determine the single most appropriate category from the list above. Return *only* the category name as a string matching one of the categories exactly. If unsure or the description is ambiguous, categorize it as "Other".
`,
});


const categorizeExpenseFlow = ai.defineFlow<
  typeof CategorizeExpenseInputSchema,
  typeof CategorizeExpenseOutputSchema
>(
  {
    name: 'categorizeExpenseFlow',
    inputSchema: CategorizeExpenseInputSchema,
    outputSchema: CategorizeExpenseOutputSchema,
  },
  async (input): Promise<CategorizeExpenseOutput> => {
    try {
        const { output } = await categorizeExpensePrompt(input);

        // Validate the output against the predefined categories
        if (output && validCategories.includes(output.category as typeof validCategories[number])) {
            return output;
        } else {
             console.warn(`Invalid or missing category returned by AI: ${output?.category}. Falling back to 'Other'. Input: ${input.description}`);
             return { category: "Other" };
        }
    } catch (error) {
         console.error(`Error during categorizeExpenseFlow for input "${input.description}":`, error);
         // Return 'Other' category in case of any error during the flow execution
         return { category: "Other" };
    }
  }
);

