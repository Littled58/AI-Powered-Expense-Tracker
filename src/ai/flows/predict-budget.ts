// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview AI-powered budget prediction flow.
 *
 * This file defines a Genkit flow that predicts future spending
 * based on historical expense data.
 *
 * - predictBudget - The main function to predict the budget.
 * - PredictBudgetInput - The input type.
 * - PredictBudgetOutput - The output type.
 */

import { ai } from '@/ai/ai-instance';
import { z } from 'genkit';
import { format } from 'date-fns';

// Define the expense shape within the input schema
const ExpenseSchema = z.object({
    id: z.string(),
    description: z.string(),
    amount: z.number(),
    category: z.string().nullable(),
    date: z.string().describe("Date of the expense in ISO format or similar."),
});

const PredictBudgetInputSchema = z.object({
  // Consider adding income if relevant for prediction context
  // income: z.number().optional().describe('The user\'s monthly income (optional).'),
  expenses: z.array(ExpenseSchema).describe('A list of past user expenses (e.g., last 1-3 months).'),
  predictionPeriod: z.string().describe('The period for which to predict the budget (e.g., "next month", "next week"). Default: "next month"'),
});
export type PredictBudgetInput = z.infer<typeof PredictBudgetInputSchema>;

const PredictedCategorySpendSchema = z.object({
    category: z.string().describe("The expense category."),
    predictedAmount: z.number().describe("The predicted spending amount for this category.")
});

const PredictBudgetOutputSchema = z.object({
  predictedTotalSpending: z.number().describe('The predicted total spending for the specified period.'),
  categoryPredictions: z.array(PredictedCategorySpendSchema).optional().describe('Optional: Predicted spending breakdown by category.'),
  confidenceNote: z.string().optional().describe('A brief note on the confidence of the prediction (e.g., based on data volume/consistency).'),
});
export type PredictBudgetOutput = z.infer<typeof PredictBudgetOutputSchema>;

export async function predictBudget(input: PredictBudgetInput): Promise<PredictBudgetOutput> {
   // Format dates before sending to the flow for consistency
   const formattedInput = {
    ...input,
    expenses: input.expenses.map(exp => ({
        ...exp,
        // Format date to YYYY-MM-DD for easier processing by the LLM
        date: format(new Date(exp.date), 'yyyy-MM-dd'),
        category: exp.category ?? 'Uncategorized' // Ensure category is never null
    }))
  };
  return predictBudgetFlow(formattedInput);
}

const predictBudgetPrompt = ai.definePrompt({
  name: 'predictBudgetPrompt',
  input: {
    schema: PredictBudgetInputSchema.extend({ // Use the extended schema with formatted dates
         expenses: z.array(ExpenseSchema.extend({
             date: z.string().describe("Date of the expense in YYYY-MM-DD format."),
             category: z.string().describe("Category of the expense.") // Category is now required string
         }))
    })
  },
  output: {
    schema: PredictBudgetOutputSchema,
  },
  prompt: `You are a financial forecasting AI. Based on the provided historical expense data, predict the user's total spending for the upcoming {{predictionPeriod}}.

Historical Expenses:
{{#each expenses}}
- Date: {{date}}, Category: {{category}}, Amount: {{amount}}
{{/each}}

Instructions:
1. Analyze the past spending patterns, considering amounts, categories, and dates.
2. Predict the total spending amount for the {{predictionPeriod}}.
3. (Optional) If possible based on the data consistency, provide a breakdown of predicted spending by major categories.
4. (Optional) Add a brief note about the prediction confidence (e.g., "High confidence due to consistent patterns", "Low confidence due to sparse data").

Return the prediction in the specified JSON format. Base predictions *only* on the provided historical data. If data is insufficient (e.g., less than a month of data for a monthly prediction), state that in the confidence note and provide a very rough estimate if possible, otherwise return 0 for amounts.

Prediction Period: {{predictionPeriod}}
`,
});


const predictBudgetFlow = ai.defineFlow<
  typeof PredictBudgetInputSchema,
  typeof PredictBudgetOutputSchema
>(
  {
    name: 'predictBudgetFlow',
    inputSchema: PredictBudgetInputSchema.extend({ // Use the extended schema with formatted dates
        expenses: z.array(ExpenseSchema.extend({
            date: z.string().describe("Date of the expense in YYYY-MM-DD format."),
            category: z.string().describe("Category of the expense.")
        }))
    }),
    outputSchema: PredictBudgetOutputSchema,
  },
  async (input) => {
     // Basic check: Need some expenses to predict
    if (!input.expenses || input.expenses.length < 10) {
      return {
        predictedTotalSpending: 0,
        confidenceNote: "Insufficient data for reliable prediction.",
        categoryPredictions: [],
      };
    }
    try {
        const { output } = await predictBudgetPrompt({
            ...input,
            predictionPeriod: input.predictionPeriod || "next month" // Default period
        });
        return output || {
            predictedTotalSpending: 0,
            confidenceNote: "Prediction generation failed.",
            categoryPredictions: [],
        };
    } catch (error) {
        console.error("Error in predictBudgetFlow:", error);
         return {
            predictedTotalSpending: 0,
            confidenceNote: "An error occurred during prediction.",
            categoryPredictions: [],
        };
    }
  }
);
